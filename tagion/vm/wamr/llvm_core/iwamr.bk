module tagion.vm.wamr.llvm_core.iwamr;

import tagion.vm.wamr.c.wasm_export;
import tagion.vm.wamr.c.lib_export;
import std.stdio;

class WamrEngine {
    private {
        RuntimeInitArgs runtime_args;
        uint heap_size = 8092;
        uint stack_size = 8092;
        uint buf_size = 0;
        char [128]error_buf;
        uint[] global_heap_buf;
        string wasm_path;
        @nogc {
            wasm_module_t wasm_module;
            wasm_module_inst_t module_inst;
            wasm_exec_env_t exec_env;
        }
    }
    void initialize() {
        runtime_args.mem_alloc_type = mem_alloc_type_t.Alloc_With_Pool;
        runtime_args.mem_alloc_option.pool.heap_buf = global_heap_buf.ptr;
        runtime_args.mem_alloc_option.pool.heap_size = cast(uint)global_heap_buf.length;
        const runtime_init_success=wasm_runtime_full_init(&runtime_args);
        auto buffer = bh_read_file_to_buffer(wasm_path, &buf_size);
        wasm_module = wasm_runtime_load(buffer, buf_size, error_buf, 128);
        module_inst = wasm_runtime_instantiate(wasm_module, stack_size, heap_size, error_buf, 128);
        exec_env = wasm_runtime_create_exec_env(module_inst, stack_size);
    }
    int call_func(string name){
        writeln("Hola");
        uint arg = 0;
        auto xfunc = wasm_runtime_lookup_function(name, toString("func1"), null);
        wasm_runtime_call_wasm(exec_env, xfunc, 1, &arg);
        return 0;
    }

    @trusted
    this (const uint heap=8092, const uint stack=8092, uint[] global_buf, string wasm){
        wasm_path = wasm;
        heap_size = heap;
        stack_size = stack;
        global_heap_buf = global_buf;
        initialize();
    }
    @trusted
    ~this() {
   }
}